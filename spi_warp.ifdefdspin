{{
  SPI interface routines for SD & SDHC & MMC cards

  Jonathan "lonesock" Dummer
  version 0.3.0  2009 July 19

  Using multiblock SPI mode exclusively.

  For the fsrw project:
  fsrw.sf.net
}}

{{
  *Blade Edition

  Nathan Dumont hairymnstr@gmail.com
  version 0.0.1  2010 March 29  - Includes RAM read/write routines for the DracBlade CP/M machine
  version 0.0.2  2010 March 30  - Now provides access to high latch for LED etc.
  version 0.0.3  2010 April 30  - Support for TriBladeProp and RamBladeProp <pullmoll@t-online.de>
}}
CON
#ifndef XMM_FUNCS
#ifdef  DracBladeProp
#define XMM_FUNCS
#elif defined(TriBladeProp)
#define XMM_FUNCS
#elif defined(RamBladeProp)
#define XMM_FUNCS
#endif  RamBladeProp
#endif  XMM_FUNCS

  ' possible card types
  type_MMC      = 1
  type_SD       = 2
  type_SDHC     = 3
  
  ' Error codes
  ERR_CARD_NOT_RESET            = -1
  ERR_3v3_NOT_SUPPORTED         = -2
  ERR_OCR_FAILED                = -3
  ERR_BLOCK_NOT_LONG_ALIGNED    = -4
  '...
  ' These errors are for the assembly engine...they are negated inside, and need to be <= 511
  ERR_ASM_NO_READ_TOKEN         = 100
  ERR_ASM_BLOCK_NOT_WRITTEN     = 101
  ' NOTE: errors -128 to -255 are reserved for reporting R1 response errors
  '...
  ERR_SPI_ENGINE_NOT_RUNNING    = -999
  ERR_CARD_BUSY_TIMEOUT          = -1000

  ' SDHC/SD/MMC command set for SPI
  CMD0    = $40+0        ' GO_IDLE_STATE 
  CMD1    = $40+1        ' SEND_OP_COND (MMC) 
  ACMD41  = $C0+41       ' SEND_OP_COND (SDC) 
  CMD8    = $40+8        ' SEND_IF_COND 
  CMD9    = $40+9        ' SEND_CSD 
  CMD10   = $40+10       ' SEND_CID 
  CMD12   = $40+12       ' STOP_TRANSMISSION
  CMD13   = $40+13       ' SEND_STATUS  
  ACMD13  = $C0+13       ' SD_STATUS (SDC)
  CMD16   = $40+16       ' SET_BLOCKLEN 
  CMD17   = $40+17       ' READ_SINGLE_BLOCK 
  CMD18   = $40+18       ' READ_MULTIPLE_BLOCK 
  CMD23   = $40+23       ' SET_BLOCK_COUNT (MMC) 
  ACMD23  = $C0+23       ' SET_WR_BLK_ERASE_COUNT (SDC)
  CMD24   = $40+24       ' WRITE_BLOCK 
  CMD25   = $40+25       ' WRITE_MULTIPLE_BLOCK 
  CMD55   = $40+55       ' APP_CMD 
  CMD58   = $40+58       ' READ_OCR
  CMD59   = $40+59       ' CRC_ON_OFF 

  ' buffer size for my debug cmd log
  LOG_SIZE = 256<<1
  speed_buf = $170

  LEDMASK = %1000
{
VAR
  long SPI_engine_cog
  ' these are used for interfacing with the assembly engine | temporary initialization usage
  long SPI_command              ' "t", "r", "w", 0 =>done, <0 => error          | pin mask
  long SPI_block_index          ' which 512-byte block to read/write            | cnt at init
  long SPI_buffer_address       ' where to get/put the data in Hub RAM          | unused
'}
DAT
'' I'm placing these variables in a DAT section to make this driver a singleton.
'' If for some reason you really need more than one driver (e.g. if you have more
'' than a single SD socket), move these back into VAR.
SPI_engine_cog          long 0
' these are used for interfacing with the assembly engine | temporary initialization usage
SPI_command             long 0  ' "t", "r", "w", 0 =>done, <0 => error          | unused
SPI_block_index         long 0  ' which 512-byte block to read/write            | cnt at init
SPI_buffer_address      long 0  ' where to get/put the data in Hub RAM          | unused
HighLatchVal            long 0
{
VAR
  ' for debug ONLY
  byte log_cmd_resp[LOG_SIZE+1]
  long dbg_ptr
  long dbg_end
PUB get_log_pointer
  return @log_cmd_resp
'}

PUB start( basepin )
{{
  This is a compatibility wrapper, and requires that the pins be
  both consecutive, and in the order DO CLK DI CS.
}}
  return start_explicit( basepin, basepin+1, basepin+2, basepin+3 )

PUB readblock( block_index, buffer_address )
  if SPI_engine_cog == 0
    abort ERR_SPI_ENGINE_NOT_RUNNING
  if (buffer_address & 3)
    abort ERR_BLOCK_NOT_LONG_ALIGNED
  SPI_block_index := block_index
  SPI_buffer_address := buffer_address
  SPI_command := "r"
  repeat while SPI_command == "r"
  if SPI_command < 0
    abort SPI_command

PUB writeblock( block_index, buffer_address )
  if SPI_engine_cog == 0
    abort ERR_SPI_ENGINE_NOT_RUNNING
  if (buffer_address & 3)
    abort ERR_BLOCK_NOT_LONG_ALIGNED
  SPI_block_index := block_index
  SPI_buffer_address := buffer_address
  SPI_command := "w"
  repeat while SPI_command == "w"
  if SPI_command < 0
    abort SPI_command


'' -- DB ------------------------------------------------------
#ifdef XMM_FUNCS
PUB writeram(hub_address, ram_address, count)
  if SPI_engine_cog == 0
    abort ERR_SPI_ENGINE_NOT_RUNNING
  SPI_block_index := ram_address
  SPI_buffer_address := ((count & $FFFF) << 16) + (hub_address & $FFFF)
  SPI_command := "W"
  repeat while SPI_command == "W"
  if SPI_command < 0
    abort SPI_command

PUB readram(hub_address, ram_address, count)
  if SPI_engine_cog == 0
    abort ERR_SPI_ENGINE_NOT_RUNNING
  SPI_block_index := ram_address
  SPI_buffer_address := ((count & $FFFF) << 16) + (hub_address & $FFFF)
  SPI_command := "R"
  repeat while SPI_command == "R"
  if SPI_command < 0
    abort SPI_command

#ifdef DracBladeProp
PUB sethighaddr(value)
  HighLatchVal := (HighLatchVal & $F0) + (value & 7)
  setha(HighLatchVal)

PUB setdebugport(value)
  HighLatchVal := (HighLatchVal & $0F) + ((value & $F) << 4)
  setha(HighLatchVal)

PUB setledon
  HighLatchVal |= LEDMASK
  setha(HighLatchVal)

PUB setledoff
  HighLatchVal &= (!LEDMASK)
  setha(HighLatchVal)

PRI setha(val)
  if SPI_engine_cog == 0
    abort ERR_SPI_ENGINE_NOT_RUNNING
  SPI_block_index := val
  SPI_buffer_address := 0
  SPI_command := "H"
  repeat while SPI_command == "H"
  if SPI_command < 0
    abort SPI_command
#endif DracBladeProp
#endif XMM_FUNCS

'' -- /DB -----------------------------------------------------
PUB get_seconds
  if SPI_engine_cog == 0
    abort ERR_SPI_ENGINE_NOT_RUNNING
  SPI_command := "t"
  repeat while SPI_command == "t"
  ' secods are in SPI_block_index, remainder is in SPI_buffer_address
  return SPI_block_index

PUB get_milliseconds : ms
  if SPI_engine_cog == 0
    abort ERR_SPI_ENGINE_NOT_RUNNING
  SPI_command := "t"
  repeat while SPI_command == "t"
  ' secods are in SPI_block_index, remainder is in SPI_buffer_address
  ms := SPI_block_index * 1000
  ms += SPI_buffer_address * 1000 / clkfreq
  
PUB start_explicit( DO, CLK, DI, CS ) : card_type | tmp, i
{{
  Do all of the card initialization in SPIN, then hand off the pin
  information to the assembly cog for hot SPI block R/W action!
}}
  ' Start from scratch
  stop
  ' clear my log buffer
  {
  bytefill( @log_cmd_resp, 0, LOG_SIZE+1 )
  dbg_ptr := @log_cmd_resp
  dbg_end := dbg_ptr + LOG_SIZE
  '}
  ' wait ~4 milliseconds
  waitcnt( 500 + (clkfreq>>8) + cnt )
  ' (start with cog variables, _BEFORE_ loading the cog)
  pinDO := DO
  maskDO := |< DO
  pinCLK := CLK
  pinDI := DI
  maskDI := |< DI
  maskCS := |< CS
  adrShift := 9 ' block = 512 * index, and 512 = 1<<9
  ' pass the output pin mask via the command register
  maskAll := maskCS | (|<pinCLK) | maskDI
  dira |= maskAll  
  ' get the card in a ready state: set DI and CS high, send => 74 clocks
  outa |= maskAll
  repeat 4096
    outa[CLK]~~
    outa[CLK]~
  ' time-hack
  SPI_block_index := cnt
  ' reset the card
  tmp~
  repeat i from 0 to 9
    if tmp <> 1
      tmp := send_cmd_slow( CMD0, 0, $95 )
      if (tmp & 4)
        ' the card said CMD0 ("go idle") was invalid, so we're possibly stuck in read or write mode
        if i & 1
          ' exit multiblock read mode
          repeat 4
            read_32_slow        ' these extra clocks are required for some MMC cards
          send_slow( $FD, 8 )   ' stop token
          read_32_slow
          repeat while read_slow <> $FF
        else
          ' exit multiblock read mode
          send_cmd_slow( CMD12, 0, $61 )           
  if tmp <> 1
    ' the reset command failed!
    crash( ERR_CARD_NOT_RESET )
  ' Is this a SD type 2 card?
  if send_cmd_slow( CMD8, $1AA, $87 ) == 1
    ' Type2 SD, check to see if it's a SDHC card
    tmp := read_32_slow
  ' check the supported voltage
    if (tmp & $1FF) <> $1AA
      crash( ERR_3v3_NOT_SUPPORTED )
    ' try to initialize the type 2 card with the High Capacity bit
    repeat while send_cmd_slow( ACMD41, |<30, $77 )
    ' the card is initialized, let's read back the High Capacity bit
    if send_cmd_slow( CMD58, 0, $FD ) <> 0
      crash( ERR_OCR_FAILED )
    ' get back the data
    tmp := read_32_slow
    ' check the bit
    if tmp & |<30
      card_type := type_SDHC
      adrShift := 0
    else
      card_type := type_SD
  else
    ' Either a type 1 SD card, or it's MMC, try SD 1st
    if send_cmd_slow( ACMD41, 0, $E5 ) < 2
      ' this is a type 1 SD card (1 means busy, 0 means done initializing)
      card_type := type_SD
      repeat while send_cmd_slow( ACMD41, 0, $E5 )
    else
      ' mark that it's MMC, and try to initialize
      card_type := type_MMC
      repeat while send_cmd_slow( CMD1, 0, $F9 )
    ' some SD or MMC cards may have the wrong block size, set it here
    send_cmd_slow( CMD16, 512, $15 )
  ' card is mounted, make sure the CRC is turned off
  send_cmd_slow( CMD59, 0, $91 )
  '  check the status
  'send_cmd_slow( CMD13, 0, $0D )    
  ' done with the SPI bus for now
  outa |= maskCS
  ' set my counter modes for super fast SPI operation
  ' writing: NCO single-ended mode, output on DI
  writeMode := (%00100 << 26) | (DI << 0)
  ' reading
  readMode := (%11000 << 26) | (DO << 0) | (CLK << 9)
  ' clock
  clockInMode := (%00110 << 26) | (CLK << 0) ' DUTY, 25% duty cycle
  ' how many bytes (8 clocks, >>3) fit into 1/2 of a second (>>1), 4 clocks per instruction (>>2)?
  N_in8_500ms := clkfreq >> constant(1+2+3)
  ' how long should we wait before auto-exiting any multiblock mode?
  idle_limit := 125 ' ms, NEVER make this > 1000
  idle_limit := clkfreq / (1000 / idle_limit) ' convert to counts
  ' Hand off control to the assembly engine's cog  
  bufAdr := @SPI_buffer_address
  sdAdr := @SPI_block_index
  SPI_command := 0 ' just make sure it's not 1
  ' start my driver cog and wait till I hear back that it's done 
  SPI_engine_cog := cognew( @SPI_engine_entry, @SPI_command ) + 1
  if SPI_engine_cog == 0
    crash( ERR_SPI_ENGINE_NOT_RUNNING )
  repeat while SPI_command <> -1
  ' and we no longer need to control any pins from here
  dira &= !maskAll
  ' the return variable is card_type   

PUB release
{{
  I do not want to abort if the cog is not
  running, as this is called from stop, which
  is called from start/ [8^)  
}}
  if SPI_engine_cog
    SPI_command := "z"
    repeat while SPI_command == "z"
    
PUB stop
{{
  kill the assembly driver cog.
}}
  release
  if SPI_engine_cog
    cogstop( SPI_engine_cog~ - 1 )

PUB get_SPI_command
  return @SPI_command

PUB get_memory
  return @SPI_engine_entry

PRI crash( abort_code )
{{
  In case of Bad Things(TM) happening,
  exit as gracefully as possible.
}}
  ' and we no longer need to control any pins from here
  dira &= !maskAll
  ' and report our error
  abort abort_code

PRI send_cmd_slow( cmd, val, crc ) : reply | time_stamp
{{
  Send down a command and return the reply.
  Note: slow is an understatement!
  Note: this uses the assembly DAT variables for pin IDs,
  which means that if you run this multiple times (say for
  multiple SD cards), these values will change for each one.
  But this is OK as all of these functions will be called
  during the initialization only, before the PASM engine is
  running.
}}
  ' if this is an application specific command, handle it
  if (cmd & $80)
    ' ACMD<n> is the command sequense of CMD55-CMD<n>
      cmd &= $7F
      reply := send_cmd_slow( CMD55, 0, $65 )
      if (reply > 1)
        return reply  
  ' the CS line needs to go low during this operation
  outa |= maskCS
  outa &= !maskCS
  ' give the card a few cocks to finish whatever it was doing
  read_32_slow
  ' send the command byte
  send_slow( cmd, 8 )
  ' send the value long
  send_slow( val, 32 )   
  ' send the CRC byte
  send_slow( crc, 8 )
  ' is this a CMD12?, if so, stuff byte
  if cmd == CMD12
    read_slow
  ' read back the response (spec declares 1-8 reads max for SD, MMC is 0-8)
  time_stamp := 9
  repeat
    reply := read_slow
  while( reply & $80 ) and ( time_stamp-- )
  ' done, and 'reply' is already pre-loaded

 { if dbg_ptr < (dbg_end-1)
    byte[dbg_ptr++] := cmd
    byte[dbg_ptr++] := reply
    if (cmd&63) == 13
      ' get the second byte
      byte[dbg_ptr++] := cmd
      byte[dbg_ptr++] := read_slow
    dbg_ptr := @log_cmd_resp
  '}  

PRI send_slow( value, bits_to_send )
  value ><= bits_to_send
  repeat bits_to_send
    outa[pinCLK]~
    outa[pinDI] := value
    value >>= 1
    outa[pinCLK]~~

PRI read_32_slow : r
  repeat 4
    r <<= 8
    r |= read_slow
  
PRI read_slow : r
{{
  Read back 8 bits from the card
}}
  ' we need the DI line high so a read can occur
  outa[pinDI]~~
  ' get 8 bits (remember, r is initialized to 0 by SPIN)
  repeat 8
    outa[pinCLK]~
    outa[pinCLK]~~
    r += r + ina[pinDO]
  ' error check
  if( (cnt - SPI_block_index) > (clkfreq << 2) )
    crash( ERR_CARD_BUSY_TIMEOUT )
   
DAT
{{
        This is the assembly engine for doing fast block
        reads and writes.  This is *ALL* it does!
}}
ORG 0
SPI_engine_entry
                        ' Counter A drives data out
                        mov ctra,writeMode
                        ' Counter B will always drive my clock line
                        mov ctrb,clockInMode
                        ' set our output pins to match the pin mask
                        mov dira,maskAll
                        ' handshake that we now control the pins
                        neg user_request,#1
                        wrlong user_request,par
                        ' start my seconds' counter here
                        mov last_time,cnt
        
waiting_for_command
                        ' update my seconds counter, but also track the idle 
                        ' time so we can to release the card after timeout.
                        call #handle_time
                        ' read the command, and make sure it's from the user (> 0)
                        rdlong user_request,par
                        cmps user_request,#0 wz,wc
                if_be   jmp #waiting_for_command
                        ' handle our card based commands
                        cmp user_request,#"r" wz
                if_z    jmp #read_ahead
                        cmp user_request,#"w" wz
                if_z    jmp #write_behind
                        cmp user_request,#"z" wz
                if_z    jmp #release_card
#ifdef XMM_FUNCS
'' -- DB -----------------------------------
                        cmp user_request,#"R" wz
                if_z    jmp #read_ram_setup
                        cmp user_request,#"W" wz
                if_z    jmp #write_ram_setup
#ifdef DracBladeProp
                        cmp user_request,#"H" wz
                if_z    jmp #high_latch_setup
#endif DracBladeProp
'' -- /DB ----------------------------------
#endif XMM_FUNCS
                        ' time requests are handled differently
                        cmp user_request,#"t" wz    ' time
                if_z    wrlong seconds,sdAdr    ' seconds goes into the SD index register
                if_z    wrlong dtime,bufAdr     ' the remainder goes into the buffer address register
                        ' in all other cases, clear the user's request
                        mov user_request,#0
                        wrlong user_request,par
                        jmp #waiting_for_command
       

release_card
                        mov user_cmd,#"z"
                        call #handle_command
                        mov user_request,user_cmd
                        wrlong user_request,par
                        jmp #waiting_for_command

read_ahead
                        rdlong user_idx,sdAdr
                        mov user_cmd,#"r"
                        call #handle_command
                        ' copy the data up into Hub RAM
                        call #cog_to_hub
                        ' signify that the data is ready, Spin can continue
                        mov user_request,user_cmd
                        wrlong user_request,par
                        ' done
                        jmp #waiting_for_command

write_behind
                        rdlong user_idx,sdAdr
                        ' copy data in from Hub RAM
                        call #hub_to_cog
                        ' signify that we have the data, Spin can continue
                        mov user_request,user_cmd
                        wrlong user_request,par
                        ' write out the block
                        mov user_cmd,#"w"
                        call #handle_command
                        ' done                      
                        jmp #waiting_for_command


#ifdef XMM_FUNCS
'' -- DB -----------------------------------------
read_ram_setup
                        rdlong user_idx,sdAdr

                        mov user_cmd,#"R"
                        call  #read_ram
                        mov   user_request,user_cmd
                        wrlong user_request, par
                        jmp #waiting_for_command

write_ram_setup
                        rdlong user_idx,sdAdr
                        mov user_cmd,#"W"
                        call  #write_ram
                        mov user_request, user_cmd
                        wrlong user_request,par
                        jmp #waiting_for_command

#ifdef DracBladeProp
high_latch_setup
                        rdlong user_idx, sdAdr
                        call  #OutputHighLatch
                        mov user_request, user_cmd
                        wrlong user_request, par
                        jmp #waiting_for_command
#endif DracBladeProp
#endif XMM_FUNCS
'' -- /DB ----------------------------------------

{{
  Set user_cmd and user_idx before calling this
}}
handle_command
                        ' Can we stay in the old mode? (address = old_address+1) && (old mode == new_mode)
                        cmp lastIndexPlus, user_idx wz
                if_z    cmp user_cmd, lastCommand wz
                if_z    jmp #:execute_block_command
                        ' we fell through, must exit the old mode!
                        cmp lastCommand,#"w" wz
                if_z    call #stop_mb_write
                        cmp lastCommand,#"r" wz  
                if_z    call #stop_mb_read
                        cmp lastCommand,#"z" wz  
                if_z    mov dira,maskAll
                        ' and start up the new mode!
                        cmp user_cmd,#"w" wz
                if_z    call #start_mb_write
                        cmp user_cmd,#"r" wz
                if_z    call #start_mb_read
                        cmp user_cmd,#"z" wz
                if_z    call #release_DO
:execute_block_command
                        ' track the (new) last index and command
                        mov lastIndexPlus, user_idx
                        add lastIndexPlus, #1
                        mov lastCommand, user_cmd
                        ' do the block read or write or terminate!
                        cmp user_cmd,#"w" wz
                if_z    call #write_single_block
                        cmp user_cmd,#"r" wz
                if_z    call #read_single_block
                        cmp user_cmd,#"z" wz
                if_z    mov user_cmd,#0
                        ' done
handle_command_ret
                        ret   

{=== these PASM functions get me in and out of multiblock mode ===}
release_DO
                        ' we're already out of multiblock mode, so
                        ' deselect the card and send out some clocks
                        or outa,maskCS
                        call #in8
                        call #in8
                        ' if you are using pull-up resistors, and need all
                        ' lines tristated, then uncomment the following line.
                        ' for Cluso99
                        mov dira, #0
release_DO_ret
                        ret
        
start_mb_read
                        movi block_cmd,#CMD18<<1
                        call #send_SPI_command_fast       
start_mb_read_ret
                        ret

stop_mb_read
                        movi block_cmd,#CMD12<<1
                        call #send_SPI_command_fast
                        call #busy_fast
stop_mb_read_ret
                        ret

start_mb_write
                        movi block_cmd,#CMD25<<1
                        call #send_SPI_command_fast
start_mb_write_ret
                        ret

stop_mb_write
                        call #busy_fast
                        ' only some cards need these extra clocks
                        mov tmp1,#16
:loopity
                        call #in8         
                        djnz tmp1,#:loopity
                        ' done with hack
                        movi phsa,#$FD<<1
                        call #out8
                        call #in8       ' stuff byte
                        call #busy_fast
stop_mb_write_ret
                        ret

send_SPI_command_fast
                        ' make sure the CS line transitions low
                        or outa,maskCS  
                        andn outa,maskCS
                        ' 8 clocks
                        call #in8 
                        ' send the data
                        mov phsa,block_cmd         ' do which ever block command this is (already in the top 8 bits)
                        call #out8                 ' write the byte
                        mov phsa,user_idx          ' read in the desired block index
                        shl phsa,adrShift          ' this will multiply by 512 (bytes/sector) for MMC and SD
                        call #out8                 ' move out the 1st MSB
                        call #out8                 ' move out the 1st MSB
                        call #out8                 ' move out the 1st MSB
                        call #out8                 ' move out the 1st MSB
                        ' bogus CRC value
                        call #in8                  ' in8 looks like out8 with $FF
                        ' CMD12 requires a stuff byte
                        shr block_cmd,#24
                        cmp block_cmd,#CMD12 wz
                if_z    call #in8                  ' 8 clocks
                        ' get the response
                        mov tmp1,#9
:cmd_response
                        call #in8
                        test readback,#$80 wc,wz
                if_c    djnz tmp1,#:cmd_response
                if_nz   neg user_cmd,readback
                        ' done        
send_SPI_command_fast_ret
                        ret    
                        
        
busy_fast
                        mov tmp1,N_in8_500ms
:still_busy
                        call #in8
                        cmp readback,#$FF wz
                if_nz   djnz tmp1,#:still_busy
busy_fast_ret
                        ret


out8
                        andn outa,maskDI 
                        movi phsb,#%11_0000000
                        movi frqb,#%01_0000000
                        rol phsa,#1
                        rol phsa,#1
                        rol phsa,#1
                        rol phsa,#1
                        rol phsa,#1
                        rol phsa,#1
                        rol phsa,#1
                        mov frqb,#0
                        ' do shift the final bit...already sent,
                        rol phsa,#1  
out8_ret
                        ret


in8
                        or outa,maskDI
                        mov ctra,readMode
                        ' Start my clock
                        mov frqa,#1<<7
                        mov phsa,#0
                        movi phsb,#%11_0000000
                        movi frqb,#%01_0000000
                        ' keep reading in my value, one bit at a time!  (Kuneko - "Wh)
                        shr frqa,#1
                        shr frqa,#1
                        shr frqa,#1
                        shr frqa,#1
                        shr frqa,#1
                        shr frqa,#1
                        shr frqa,#1
                        mov frqb,#0 ' stop the clock
                        mov readback,phsa
                        mov frqa,#0
                        mov ctra,writeMode
in8_ret
                        ret
        
        
' this is called more frequently than 1 Hz, and
' is only called when the user command is 0.
handle_time        
                        mov     tmp1,cnt            ' get the current timestamp
                        add     idle_time,tmp1      ' add the current time to my idle time counter
                        sub     idle_time,last_time ' subtract the last time from my idle counter (hence delta)    
                        add     dtime,tmp1          ' add to my accumulator, 
                        sub     dtime,last_time     ' and subtract the old (adding delta)
                        mov     last_time,tmp1      ' update my "last timestamp"        
                        rdlong  tmp1,#0             ' what is the clock frequency?
                        cmpsub  dtime,tmp1 wc       ' if I have more than a second in my accumulator
                        addx    seconds,#0          ' then add it to "seconds"
                        ' this part is to auto-release the card after a timeout
                        cmp     idle_time,idle_limit wz,wc
                if_b    jmp     #handle_time_ret    ' don't clear if we haven't hit the limit
                        mov     user_cmd,#"z"       ' we can't overdo it, the command handler makes sure
                        call    #handle_command     ' release the card, but don't mess with the user's request register
handle_time_ret
                        ret

hub_to_cog              ' reset the cog address and get the Hub address
                        movd    :read_long1, #speed_buf  ' no unrolling for the small version
                        rdlong  buf_ptr, bufAdr
                        mov     ops_left, #128           ' 128 longs (512 bytes) / unroll factor
:read_long1             rdlong  0-0, buf_ptr
                        add     :read_long1, const512    ' adds 1 to destination (bits 17..9)
                        add     buf_ptr, #4
                        djnz    ops_left, #:read_long1
hub_to_cog_ret
                        ret

cog_to_hub              ' reset the cog address and get the Hub address 
                        movd    :write_long1, #speed_buf
                        rdlong  buf_ptr, bufAdr   
                        mov     ops_left, #128           ' 128 longs (512 bytes) / unroll factor
:write_long1            wrlong  0-0, buf_ptr
                        add     :write_long1, const512   ' adds 1 to destination (bits 17..9)
                        add     buf_ptr, #4
                        djnz    ops_left, #:write_long1
cog_to_hub_ret
                        ret             

read_single_block
                        ' where am I sending the data?
                        movd    :store_read_long, #speed_buf
                        mov     ops_left, #128
                        ' wait until the card is ready
                        mov     tmp1, N_in8_500ms
:get_resp
                        call    #in8
                        cmp     readback, #$FE      wz        
                if_nz   djnz    tmp1, #:get_resp
                if_nz   neg     user_cmd, #ERR_ASM_NO_READ_TOKEN  
                if_nz   jmp     #read_single_block_ret
                        ' read the data
:read_loop
                        mov     readback32, #0
                        mov     tmp1, #4
:byte_in
                        ror     readback32, #8
                        call    #in8
                        or      readback32, readback
                        djnz    tmp1, #:byte_in
                        ror     readback32, #8
:store_read_long        mov     0-0, readback32  
                        add     :store_read_long, const512
                        djnz    ops_left, #:read_loop
        
                        ' now read 2 trailing bytes (CRC)
                        call    #in8              ' out8 is 2x faster than in8
                        call    #in8              ' and I'm not using the CRC anyway
                        ' give an extra 8 clocks in case we pause for a long time
                        call    #in8              ' in8 looks like out8($FF)
        
                        ' all done successfully
                        mov idle_time, #0
                        mov user_cmd, #0               
read_single_block_ret
                        ret          
        
write_single_block               
                        ' where am I getting the data? (all 512 bytes / 128 longs of it?)
                        movs    :write_loop,#speed_buf
                        ' read in 512 bytes (128 longs) from Hub RAM and write it to the card
                        mov     ops_left,#128        
                        ' just hold your horses  
                        call    #busy_fast 
                        ' $FC for multiblock, $FE for single block
                        movi    phsa, #$FC<<1
                        call    #out8
:write_loop
                        ' write 4 bytes
                        mov     phsa, 0-0
                        add     :write_loop, #1
                        ' a long in LE order is DCBA
                        rol     phsa, #8            ' move A7 into position, _after_ the next rol 16
                        mov     tmp1, #4
:byte_out
                        rol     phsa, #16
                        call    #out8
                        djnz    tmp1, #:byte_out
                        djnz    ops_left, #:write_loop
                        ' write out my two (bogus, using $FF) CRC bytes
                        call    #in8
                        call    #in8
                        ' now read response (I need this response, so can't spoof using out8)
                        call    #in8
                        and     readback, #$1F
                        cmp     readback, #5      wz
                if_z    mov     user_cmd, #0         ' great
                if_nz   neg     user_cmd, #ERR_ASM_BLOCK_NOT_WRITTEN ' oops
                        ' send out another 8 clocks
                        call    #in8 
                        ' all done
                        mov     idle_time,#0
write_single_block_ret
                        ret


#ifdef XMM_FUNCS
''----------------------------------------------------------------------------------
'' DracBlade RAM driver routines
''----------------------------------------------------------------------------------
''
''                      Included by Nathan Dumont (hairymnstr@gmail.com)
''
'' v_0_0_1    -         Initial inclusion, there is no clever buffering or anything
''                      RAM is transferred directly to hub space.
''
#ifdef DracBladeProp
read_ram                rdlong  buf_ptr, bufAdr
                        mov     ramcount, buf_ptr
                        shr     ramcount, #16
                        and     buf_ptr, halfmask
rdloop
                        call    #set_ram_address        ' sets up the latches with the correct ram address
                        andn    dira, #$ff
                        andn    outa, LatchDirection    ' clear address bits (read = 0000 on 138)
                        add     user_idx, #1            ' external ram address++
                        or      outa, GateHigh          ' set the gate high again
                        mov     data_8, ina
                        wrbyte  data_8, buf_ptr         ' write data_8 to hubaddr ie copy byte to hub
                        add     buf_ptr, #1             ' hub ram address++
                        djnz    ramCount, #rdloop       ' loop until done
                        andn    dira, latchdirection
                        mov     user_cmd, #0            ' OK
read_ram_ret            ret


write_ram               rdlong  buf_ptr, bufAdr
                        mov     ramcount, buf_ptr
                        shr     ramcount, #16
                        and     buf_ptr, halfmask
wrblock
wrloop                  rdbyte  data_8, buf_ptr         ' copy byte from hub
                        call    #set_ram_address        ' sets up the latches with the correct ram address
                        mov     outx, data_8            ' get the byte to output
                        and     outx, #$FF              ' ensure upper bytes=0
                        or      outx, WriteEnable       ' or with correct 138 address
                        andn    outa, latchdirection
                        or      outa, outx              ' send it out
                        add     buf_ptr, #1             ' add 1 to hub address
                        add     user_idx, #1            ' add 1 to ram address
                        or      outa,GateHigh           ' set it high again
                        djnz    ramCount, #wrloop       ' loop until done
                        andn    dira, latchdirection    ' tristate lines so others can use
                        mov     user_cmd, #0
write_ram_ret           ret

set_ram_address         ' Sets up the RAM latches. Assumes high latch A16-A18 low so only accesses 64k of ram
                        or      dira, LatchDirection    ' set up the pins for programming latch chips
                        mov     outx, user_idx          ' get the address into a temp variable
                        and     outx, #$FF              ' mask the low byte
                        or      outx, LowAddress        ' or with 138 low address
                        andn    outa, LatchDirection
                        or      outa, outx              ' send it out
                        or      outa, GateHigh          ' set it high again
                                                        ' now repeat for the middle byte
                        mov     outx, user_idx          ' get the address into a temp variable
                        shr     outx, #8                ' shift right by 8 places
                        and     outx, #$FF              ' mask the low byte
                        or      outx, MiddleAddress     ' or with 138 middle address
                        andn    outa, LatchDirection
                        or      outa, outx              ' send it out
                        or      outa, GateHigh          ' set it high again
set_ram_address_ret
                        ret

OutputHighLatch ' sends out HighLatch to the 374 that does A16-19, led and the 4 spare outputs
                        or      dira,latchdirection     ' setup active pins 138 and bus
                        andn    outa, latchdirection
                        or      outa,user_idx           ' send out user_idx
                                ' note it's up to spin now to keep track of the state
                                ' of the high latch
                        or      outa,HighAddress        ' or with the high address
                        or      outa,GateHigh           ' set the gate high again
                        andn    dira, latchdirection    ' tristate the bus so ZiCOG can use it
                        mov     user_cmd, #0            ' signal okay
OutputHighLatch_ret     ret
#endif DracBladeProp

#ifdef TriBladeProp
read_ram                rdlong  buf_ptr, bufAdr
                        mov     ramcount, buf_ptr
                        shr     ramcount, #16
                        and     buf_ptr, halfmask
rdloop                  mov     outx, user_idx
                        shl     outx, #8                ' shift address 8 bits
                        or      outx, ram_read          ' add -WE=1 -OE=0
                        mov     outa, outx              ' pc (shifted 8 bits + -WE=1 -OE=0)
                        add     user_idx, #1            ' external ram address++
                        mov     data_8, ina             ' read SRAM
                        wrbyte  data_8, buf_ptr         ' write data_8 to hubaddr ie copy byte to hub
                        add     buf_ptr, #1             ' hub ram address++
                        djnz    ramCount, #rdloop       ' loop until done
                        mov     user_cmd, #0            ' OK
read_ram_ret            ret


write_ram               rdlong  buf_ptr, bufAdr
                        mov     ramcount, buf_ptr
                        shr     ramcount, #16
                        and     buf_ptr, halfmask
wrblock
wrloop                  rdbyte  data_8, buf_ptr         ' copy byte from hub
                        mov	outx, user_idx
                        shl	outx, #8                ' shift address 8 bits
                        or	outx, ram_write         ' add -WE=0 -OE=1
                        and	data_8, #$ff            ' ensure upper bytes=0
                        or	outx, data_8            ' add data bits to be written
                        mov	outa, outx              ' output -WE=0 -OE=1, address bits, data bits
                        mov	dira, ram_dir_write     ' set data bits to outputs
                        or      outa, ram_latched       ' set -WE=0->1 -OE=1->1  (end write)
                        add     buf_ptr, #1             ' add 1 to hub address
                        add     user_idx, #1            ' add 1 to ram address
                        djnz    ramCount, #wrloop       ' loop until done
                        mov     dira, ram_dir_read      ' set data bits to inputs
                        mov     outa, ram_read          ' set -WE=1 -OE=0
                        mov     user_cmd, #0
write_ram_ret           ret
#endif TriBladeProp

#ifdef RamBladeProp
read_ram                rdlong  buf_ptr, bufAdr
                        mov     ramcount, buf_ptr
                        shr     ramcount, #16
                        and     buf_ptr, halfmask
			mov     outa, user_idx          ' setup read address incl -CE=0 -WE=0
                        mov     dira, ram_dir_read      ' set outputs A0-18, CE
                        nop                             ' sram delay required
rdloop                  mov     outa, user_idx          ' setup read address incl -CE=0 -WE=0
                        add     user_idx, #1            ' external ram address++
                        mov     data_8, ina             ' read byte from SRAM   \
                        ror     data_8, #24             ' shift to lower 8 bits |
                        wrbyte  data_8, buf_ptr         ' write data_8 to hubaddr ie copy byte to hub
                        add     buf_ptr, #1             ' hub ram address++
                        djnz    ramCount, #rdloop       ' loop until done
                        mov     user_cmd, #0            ' OK
read_ram_ret            ret


write_ram               rdlong  buf_ptr, bufAdr
                        mov     ramcount, buf_ptr
                        shr     ramcount, #16
                        and     buf_ptr, halfmask
wrblock
                        mov     outa, user_idx          ' setup read address incl -CE=0 -WE=0
                        mov     dira, ram_dir_write     ' outputs address + data only
wrloop                  rdbyte  data_8, buf_ptr         ' copy byte from hub
                        mov     outx, data_8            ' get data into outx
                        rol     outx, #24               ' place in top 8 bits   |
                        or      outx, user_idx          ' add user_idx bits     /
                        mov     outa, outx              ' address + data + -CE=0, -WE=0
                        mov     dira, ram_dir_wstrobe   ' -CE=-WE= 1 -> 0       \ ce + we pulse
                        add     buf_ptr,#1              ' add 1 to hub address
                        mov     dira, ram_dir_write     ' address + data only   /
                        add     user_idx, #1            ' add 1 to ram address
                        djnz    ramCount, #wrloop       ' loop until done
                        mov     dira, #0                ' all inputs
                        mov     user_cmd, #0
write_ram_ret           ret
#endif RamBladeProp

'' ----------------------
'' ram access variables
'' ----------------------
ramcount                long    0
halfmask                long    $0000FFFF
outx                    long    0                                    ' for temp use, same as n in the spin code
data_8                  long    0

#ifdef DracBladeProp
GateHigh                long    %00000000_00000000_00000001_00000000 ' HC138 gate high, all others must be low
LatchDirection          long    %00000000_00000000_00001111_11111111 ' 138 active, gate active and 8 data lines active
LowAddress              long    %00000000_00000000_00000100_00000000 ' low address latch = xxxx010x and gate low xxxxxxx0
MiddleAddress           long    %00000000_00000000_00000110_00000000 ' middle address latch = xxxx011x and gate low xxxxxxx0
HighAddress             long    %00000000_00000000_00001000_00000000 ' high address latch = xxxx100x and gate low xxxxxxx0
WriteEnable             long    %00000000_00000000_00000010_00000000 ' /WE = xxxx001x and gate high xxxxxxx1
HighLatch               long    %00000000_00000000_00000000_00000000 ' static value for the 374 latch that does the led, hA16-A19 and the other 4 outputs
#endif DracBladeProp

#ifdef TriBladeProp
'                                          +-------- -CS (U26 FLASH)   -+                                  
'                                          |+------- -CS (J22 microSD)  +- Latched pins...                 
'                                          ||+------ -RST3              |    passes when LE=1              
'             (P30) SO ---+                |||+----- -RST1              |    latches on  LE low going edge 
'             (P31) SI --+|                ||||+---- -CE (U24 SRAM-hi)  |    latched on  LE=0              
'                        ||+---- -WE(SDA)  |||||+--- -CE (U23 SRAM-lo)  |                                  
'                        |||+--- -OE(SCL)  ||||||+-- A20                |                                  
'                        ||||+--  LE       |||||||+- A19               -+                                  
'                        |||||             ||||||||                                                        
'          P31...P0 --> %00xx0_xxxxxxxxxxx_xxxxxxxx_xxxxxxxx  
ram_latched	long	%00110_00000000000_00000000_00000000	' -WE=1 -OE=1 (LE=0)                               
ram_read	long	%00100_00000000000_00000000_00000000	' -WE=1 -OE=0 (LE=0)    
ram_write	long	%00010_00000000000_00000000_00000000	' -WE=0 -OE=1 (LE=0)
ram_dir_read	long	%00110_11111111111_11111111_00000000	' outputs WE, OE, A0-18, inputs D0-7
ram_dir_write	long	%00110_11111111111_11111111_11111111	' outputs WE, OE, A0-18, D0-7
ram_dir_input	long	%00000_00000000000_00000000_00000000	' all inputs (for Ram Disk access)
'                              +---------+ +------+ +------+
'                              A18......A8 A7....A0 D7....D0
'                                          Q7....Q0
'
'***************************************************************************************************************
#endif TriBladeProp

#ifdef RamBladeProp
'
' RamBlade Hardware Access:
'       P0-18  = A0-18   SRAM address
'       P19    = -CS     microSD
'       P20    = -CE     SRAM & enable eeprom
'       P21    = -WE     SRAM & enable eeprom
'       P22    = SO      \ not used by this driver
'       P23    = SI      /
'       P24-31 = D0-7    SRAM \ * see below
'                             | P28 = SCL eeprom
'                             | P29 = SDA eeprom
'                             | P30 = prog SO
'                             / P31 = prog SI
'
'         (microSD) DO ---------+
'         (microSD) DI --------+| +--------  SI (P23)
'         (microSD) CLK-------+|| |+-------  SO (P22)
'                             ||| ||
'             (P28) SCL ----+ ||| ||+------ -WE (SRAM & enable eeprom)
'             (P29) SDA ---+| ||| |||+----- -CE (SRAM & enable eeprom)
'             (P30) SO ---+|| ||| ||||+---- -CS (microSD)
'             (P31) SI --+||| ||| |||||
'                        |||| ||| |||||
'          P31...P0 --> %xxxxxxxx_00xxx_xxxxxxxxxxxxxxxxxxx
'       10K pullups -->    ** ***   ***
'                        +------+       +-----------------+
'                        D7....D0       A18..............A0
ram_dir_read    long    %00000000_00010_1111111111111111111 ' outputs CE, A0-18           (sram read)
ram_dir_write   long    %11111111_00000_1111111111111111111 ' outputs A0-18, D0-7         (sram disabled)
ram_dir_wstrobe long    %11111111_00110_1111111111111111111 ' outputs CE, WE, A0-19, D0-7 (write strobe)
#endif RamBladeProp
#endif XMM_FUNCS

{=== Assembly Interface Variables ===}
pinDO         long 0    ' pin is controlled by a counter
pinCLK        long 0    ' pin is controlled by a counter
pinDI         long 0    ' pin is controlled by a counter
maskDO        long 0    ' mask for reading the DO line from the card
maskDI        long 0    ' mask for setting the pin high while reading  
maskCS        long 0    ' mask = (1<<pin), and is controlled directly
maskAll       long 0
adrShift      long 9    ' will be 0 for SDHC, 9 for MMC & SD
bufAdr        long 0    ' where in Hub RAM is the buffer to copy to/from?
sdAdr         long 0    ' where on the SD card does it read/write?
writeMode     long 0    ' the counter setup in NCO single ended, clocking data out on pinDI
'clockOutMode  long 0    ' the counter setup in NCO single ended, driving the clock line on pinCLK
N_in8_500ms   long 1_000_000 ' used for timeout checking in PASM
readMode      long 0
clockInMode   long 0
const512      long 512           

{=== Initialized PASM Variables ===}
seconds       long 0
dtime         long 0
idle_time     long 0
idle_limit    long 0

{=== Multiblock State Machine ===}
lastIndexPlus long -1   ' state handler will check against lastIndexPlus, which will not have been -1
lastCommand   long 0    ' this will never be the last command.

{=== Debug Logging Pointers ===}
{
dbg_ptr       long 0
dbg_end       long 0
'}

{=== Assembly Scratch Variables ===}
ops_left      res 1     ' used as a counter for bytes, words, longs, whatever (start w/ # byte clocks out)
readback      res 1     ' all reading from the card goes through here
readback32    res 1     ' all reading from the card goes through here
tmp1          res 1     ' this may get used in all subroutines...don't use except in lowest 
user_request  res 1     ' the main command variable, read in from Hub: "r"-read single, "w"-write single
user_cmd      res 1     ' used internally to handle actual commands to be executed
user_idx      res 1     ' the pointer to the Hub RAM where the data block is/goes
block_cmd     res 1     ' one of the SD/MMC command codes, no app-specific allowed
buf_ptr       res 1     ' moving pointer to the Hub RAM buffer
last_time     res 1     ' tracking the timestamp

{{
  496 longs is my total available space in the cog,
  and I want 128 longs for eventual use as one 512-
  byte buffer.   This gives me a total of 368 longs
  to use for umount, and a readblock and writeblock
  for both Hub RAM and Cog buffers.
}}
        fit   $170
'        org   $170
'speed_buf     long      0   ' 512 bytes to be used for read-ahead / write-behind

'fit 467
'FIT 496

''      MIT LICENSE
{{
'  Permission is hereby granted, free of charge, to any person obtaining
'  a copy of this software and associated documentation files
'  (the "Software"), to deal in the Software without restriction,
'  including without limitation the rights to use, copy, modify, merge,
'  publish, distribute, sublicense, and/or sell copies of the Software,
'  and to permit persons to whom the Software is furnished to do so,
'  subject to the following conditions:
'
'  The above copyright notice and this permission notice shall be included
'  in all copies or substantial portions of the Software.
'
'  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
'  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
'  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
'  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
'  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
'  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
'  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}}
